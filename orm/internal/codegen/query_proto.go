package codegen

import (
	"bytes"
	"fmt"
	"os"
	"strings"

	ormv1 "cosmossdk.io/api/cosmos/orm/v1"
	"github.com/gertd/go-pluralize"
	"github.com/iancoleman/strcase"
	"golang.org/x/exp/maps"
	"golang.org/x/exp/slices"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"

	"github.com/cosmos/cosmos-sdk/orm/internal/fieldnames"
)

type queryProtoGen struct {
	*protogen.File
	imports map[string]bool
	svc     *writer
	msgs    *writer
	outFile *os.File
}

func (g queryProtoGen) gen() error {
	g.imports[g.Desc.Path()] = true
	g.imports["google/api/annotations.proto"] = true

	svcName := queryServiceName(g.File)
	g.svc.F("// %sService queries the state of the tables specified by %s.", svcName, g.Desc.Path())
	g.svc.F("service %sService {", svcName)
	g.svc.Indent()
	for _, msg := range g.Messages {
		tableDesc := proto.GetExtension(msg.Desc.Options(), ormv1.E_Table).(*ormv1.TableDescriptor)
		if tableDesc != nil {
			err := g.genTableRPCMethods(msg, tableDesc)
			if err != nil {
				return err
			}
		}
		singletonDesc := proto.GetExtension(msg.Desc.Options(), ormv1.E_Singleton).(*ormv1.SingletonDescriptor)
		if singletonDesc != nil {
			err := g.genSingletonRPCMethods(msg)
			if err != nil {
				return err
			}
		}
	}
	g.svc.Dedent()
	g.svc.F("}")
	g.svc.F("")

	outBuf := newWriter()
	outBuf.F("// Code generated by protoc-gen-go-cosmos-orm-proto. DO NOT EDIT.")
	outBuf.F(`syntax = "proto3";`)
	outBuf.F("package %s;", g.Desc.Package())
	outBuf.F("")

	imports := maps.Keys(g.imports)
	slices.Sort(imports)
	for _, i := range imports {
		outBuf.F(`import "%s";`, i)
	}
	outBuf.F("")

	_, err := outBuf.Write(g.svc.Bytes())
	if err != nil {
		return err
	}

	_, err = outBuf.Write(g.msgs.Bytes())
	if err != nil {
		return err
	}

	_, err = g.outFile.Write(outBuf.Bytes())
	if err != nil {
		return err
	}

	return g.outFile.Close()
}

func (g queryProtoGen) genTableRPCMethods(msg *protogen.Message, desc *ormv1.TableDescriptor) error {
	name := msg.Desc.Name()
	primaryKeyFields := fieldnames.CommaSeparatedFieldNames(desc.PrimaryKey.Fields)
	fields := msg.Desc.Fields()

	g.svc.F("// %s queries the %s table by its primary key.", name, name)
	g.svc.F("rpc %s(%sRequest) returns (%sResponse) {", name, name, name)
	g.svc.Indent()
	g.svc.F("option (google.api.http) = {")
	restPath := makeRestPath(msg.Desc.FullName())
	g.svc.Indent()
	var pathSegments []string
	for _, fieldName := range primaryKeyFields.Names() {
		pathSegments = append(pathSegments, fmt.Sprintf("{%s}", fieldName))
	}
	g.svc.F(`get: "/%s/%s"`, restPath, strings.Join(pathSegments, "/"))
	g.svc.Dedent()
	g.svc.F("};")
	g.svc.Dedent()
	g.svc.F("}")

	g.startRequestType("%sRequest", name)
	g.msgs.Indent()
	for i, fieldName := range primaryKeyFields.Names() {
		field := fields.ByName(fieldName)
		if field == nil {
			return fmt.Errorf("can't find primary key field %s", fieldName)
		}
		g.msgs.F("// %s specifies the value of the %s field in the primary key.", fieldName, fieldName)
		g.msgs.F("%s %s = %d;", g.fieldType(field), fieldName, i+1)
	}
	g.msgs.Dedent()

	g.msgs.F("}")
	g.msgs.F("")
	g.startResponseType("%sResponse", name)
	g.msgs.Indent()
	g.msgs.F("// value is the response value.")
	g.msgs.F("%s value = 1;", name)
	g.msgs.Dedent()
	g.msgs.F("}")
	g.msgs.F("")

	// unique index methods
	for _, idx := range desc.Index {
		if !idx.Unique {
			continue
		}

		fieldsCamel := fieldsToCamelCase(idx.Fields)
		methodName := fmt.Sprintf("%sBy%s", name, fieldsCamel)
		g.svc.F("// %s queries the %s table by its %s index", methodName, name, fieldsCamel)
		g.svc.F("rpc %s(%sRequest) returns (%sResponse) {", methodName, methodName, methodName)
		g.svc.Indent()
		g.svc.F("option (google.api.http) = {")
		g.svc.Indent()
		var pathSegments []string
		fieldNames := fieldnames.CommaSeparatedFieldNames(idx.Fields)
		for _, fieldName := range fieldNames.Names() {
			pathSegments = append(pathSegments, fmt.Sprintf("{%s}", fieldName))
		}
		g.svc.F(`get: "/%s.%s/%s"`, restPath,
			fieldsToKebabCase(idx.Fields),
			strings.Join(pathSegments, "/"))
		g.svc.Dedent()
		g.svc.F("};")
		g.svc.Dedent()
		g.svc.F("}")

		g.startRequestType("%sRequest", methodName)
		g.msgs.Indent()
		for i, fieldName := range fieldNames.Names() {
			field := fields.ByName(fieldName)
			if field == nil {
				return fmt.Errorf("can't find unique index field %s", fieldName)
			}
			g.msgs.F("%s %s = %d;", g.fieldType(field), fieldName, i+1)
		}
		g.msgs.Dedent()

		g.msgs.F("}")
		g.msgs.F("")
		g.startResponseType("%sResponse", methodName)
		g.msgs.Indent()
		g.msgs.F("%s value = 1;", name)
		g.msgs.Dedent()
		g.msgs.F("}")
		g.msgs.F("")
	}

	g.imports["cosmos/base/query/v1beta1/pagination.proto"] = true

	// primary key list method
	pluralMethod := makePluralMethodName(name)
	g.svc.F("// %s queries the %s table using the primary key index.", pluralMethod, name)
	g.svc.F("rpc %s(%sRequest) returns (%sResponse) {", pluralMethod, pluralMethod, pluralMethod)
	g.svc.Indent()
	g.svc.F("option (google.api.http) = {")
	g.svc.Indent()
	g.svc.F(`get: "/%s"`, restPath)
	g.svc.Dedent()
	g.svc.F("};")
	g.svc.Dedent()
	g.svc.F("}")
	keyFields := primaryKeyFields.Names()
	keyFields = keyFields[:len(keyFields)-1]
	g.listRequestResponseTypes(name, pluralMethod, keyFields, fields)

	for _, index := range desc.Index {
		keyFields := fieldnames.CommaSeparatedFieldNames(index.Fields).Names()
		camelNames := make([]string, len(keyFields))
		for i, field := range keyFields {
			camelNames[i] = strcase.ToCamel(string(field))
		}
		methodName := pluralMethod + "By" + strings.Join(camelNames, "")
		g.svc.F("// %s queries the %s table using the primary key index.", methodName, name)
		g.svc.F("rpc %s(%sRequest) returns (%sResponse) {", methodName, methodName, methodName)
		g.svc.Indent()
		g.svc.F("option (google.api.http) = {")
		g.svc.Indent()
		g.svc.F(`get: "/%s-by-%s"`, restPath, fieldsToKebabCase(index.Fields))
		g.svc.Dedent()
		g.svc.F("};")
		g.svc.Dedent()
		g.svc.F("}")
		g.listRequestResponseTypes(name, methodName, keyFields, fields)
	}

	//g.msgs.Indent()
	//g.msgs.F("// IndexKey specifies the value of an index key to use in prefix and range queries.")
	//g.msgs.F("message IndexKey {")
	//g.msgs.Indent()
	//indexFields := []string{desc.PrimaryKey.Fields}
	//// the primary key has field number 1
	//fieldNums := []uint32{1}
	//for _, index := range desc.Index {
	//	indexFields = append(indexFields, index.Fields)
	//	// index field numbers are their id + 1
	//	fieldNums = append(fieldNums, index.Id+1)
	//}
	//
	//g.msgs.F("// key specifies the index key value.")
	//g.msgs.F("oneof key {")
	//g.msgs.Indent()
	//for i, fields := range indexFields {
	//	fieldName := fieldsToSnakeCase(fields)
	//	typeName := fieldsToCamelCase(fields)
	//	g.msgs.F("// %s specifies the value of the %s index key to use in the query.", fieldName, typeName)
	//	g.msgs.F("%s %s = %d;", typeName, fieldName, fieldNums[i])
	//}
	//g.msgs.Dedent()
	//g.msgs.F("}")
	//
	//for _, fieldNames := range indexFields {
	//	g.msgs.F("")
	//	g.msgs.F("message %s {", fieldsToCamelCase(fieldNames))
	//	g.msgs.Indent()
	//	for i, fieldName := range fieldnames.CommaSeparatedFieldNames(fieldNames).Names() {
	//		g.msgs.F("// %s is the value of the %s field in the index.", fieldName, fieldName)
	//		g.msgs.F("// It can be omitted to query for all valid values of that field in this segment of the index.")
	//		g.msgs.F("optional %s %s = %d;", g.fieldType(fields.ByName(fieldName)), fieldName, i+1)
	//	}
	//	g.msgs.Dedent()
	//	g.msgs.F("}")
	//}
	//
	//g.msgs.Dedent()
	//g.msgs.F("}")
	//g.msgs.F("")
	//g.msgs.F("// query specifies the type of query - either a prefix or range query.")
	//g.msgs.F("oneof query {")
	//g.msgs.Indent()
	//g.msgs.F("// prefix_query specifies the index key value to use for the prefix query.")
	//g.msgs.F("IndexKey prefix_query = 1;")
	//g.msgs.F("// range_query specifies the index key from/to values to use for the range query.")
	//g.msgs.F("RangeQuery range_query = 2;")
	//g.msgs.Dedent()
	//g.msgs.F("}")
	//
	//g.msgs.F("// pagination specifies optional pagination parameters.")
	//g.msgs.F("cosmos.base.query.v1beta1.PageRequest pagination = 3;")
	//g.msgs.F("")
	//g.msgs.F("// RangeQuery specifies the from/to index keys for a range query.")
	//g.msgs.F("message RangeQuery {")
	//g.msgs.Indent()
	//g.msgs.F("// from is the index key to use for the start of the range query.")
	//g.msgs.F("// To query from the start of an index, specify an index key for that index with empty values.")
	//g.msgs.F("IndexKey from = 1;")
	//g.msgs.F("// to is the index key to use for the end of the range query.")
	//g.msgs.F("// The index key type MUST be the same as the index key type used for from.")
	//g.msgs.F("// To query from to the end of an index it can be omitted.")
	//g.msgs.F("IndexKey to = 2;")
	//g.msgs.Dedent()
	//g.msgs.F("}")
	//g.msgs.Dedent()
	//g.msgs.F("}")
	//g.msgs.F("")
	//g.startResponseType("%sResponse", listMethodName)
	//g.msgs.Indent()
	//g.msgs.F("// values are the results of the query.")
	//g.msgs.F("repeated %s values = 1;", name)
	//g.msgs.F("// pagination is the pagination response.")
	//g.msgs.F("cosmos.base.query.v1beta1.PageResponse pagination = 2;")
	//g.msgs.Dedent()
	//g.msgs.F("}")
	//g.msgs.F("")
	return nil
}

func (g queryProtoGen) genSingletonRPCMethods(msg *protogen.Message) error {
	name := msg.Desc.Name()
	g.svc.F("// %s queries the %s singleton.", name, name)
	g.svc.F("rpc %s (%sRequest) returns (%sResponse) {}", name, name, name) // TODO grpc gateway
	g.startRequestType("%sRequest", name)
	g.msgs.F("}")
	g.msgs.F("")
	g.startRequestType("%sResponse", name)
	g.msgs.Indent()
	g.msgs.F("%s value = 1;", name)
	g.msgs.Dedent()
	g.msgs.F("}")
	g.msgs.F("")
	return nil
}

func (g queryProtoGen) startRequestType(format string, args ...any) {
	g.startRequestResponseType("request", format, args...)
}

func (g queryProtoGen) startResponseType(format string, args ...any) {
	g.startRequestResponseType("response", format, args...)
}

func (g queryProtoGen) startRequestResponseType(typ string, format string, args ...any) {
	msgTypeName := fmt.Sprintf(format, args...)
	g.msgs.F("// %s is the %s/%s %s type.", msgTypeName, queryServiceName(g.File), msgTypeName, typ)
	g.msgs.F("message %s {", msgTypeName)
}

func (g queryProtoGen) listRequestResponseTypes(name protoreflect.Name, methodName string, keyFields []protoreflect.Name, fields protoreflect.FieldDescriptors) {
	g.startRequestType("%sRequest", methodName)
	g.msgs.Indent()
	i := 1
	for ; i <= len(keyFields); i++ {
		fieldName := keyFields[i-1]
		g.msgs.F("// %s is the value of the %s field in the index.", fieldName, fieldName)
		g.msgs.F("// It can be omitted to query for all valid values of that field in this segment of the index.")
		g.msgs.F("optional %s %s = %d;", g.fieldType(fields.ByName(fieldName)), fieldName, i)
	}
	g.msgs.F("// pagination specifies optional pagination parameters.")
	g.msgs.F("cosmos.base.query.v1beta1.PageRequest pagination = %d;", i)
	g.msgs.Dedent()
	g.msgs.F("}")
	g.msgs.F("")

	g.startResponseType("%sResponse", methodName)
	g.msgs.Indent()
	g.msgs.F("// values are the results of the query.")
	g.msgs.F("repeated %s values = 1;", name)
	g.msgs.F("// pagination is the pagination response.")
	g.msgs.F("cosmos.base.query.v1beta1.PageResponse pagination = 2;")
	g.msgs.Dedent()
	g.msgs.F("}")
	g.msgs.F("")
}

func queryServiceName(file *protogen.File) string {
	return fmt.Sprintf("%sQuery", strcase.ToCamel(fileShortName(file.Proto.GetName())))
}

func (g queryProtoGen) fieldType(descriptor protoreflect.FieldDescriptor) string {
	if descriptor.Kind() == protoreflect.MessageKind {
		message := descriptor.Message()
		g.imports[message.ParentFile().Path()] = true
		return string(message.FullName())
	}

	return descriptor.Kind().String()
}

type writer struct {
	*bytes.Buffer
	indent    int
	indentStr string
}

func newWriter() *writer {
	return &writer{
		Buffer: &bytes.Buffer{},
	}
}

func (w *writer) F(format string, args ...interface{}) {
	_, err := w.Write([]byte(w.indentStr))
	if err != nil {
		panic(err)
	}

	_, err = fmt.Fprintf(w, format, args...)
	if err != nil {
		panic(err)
	}

	_, err = fmt.Fprintln(w)
	if err != nil {
		panic(err)
	}
}

func (w *writer) Indent() {
	w.indent += 1
	w.updateIndent()
}

func (w *writer) updateIndent() {
	w.indentStr = ""
	for i := 0; i < w.indent; i++ {
		w.indentStr += "  "
	}
}

func (w *writer) Dedent() {
	w.indent -= 1
	w.updateIndent()
}

var pluralClient = pluralize.NewClient()

func makePluralMethodName(name protoreflect.Name) string {
	str := string(name)
	if pluralClient.IsPlural(str) {
		return fmt.Sprintf("List%s", str)
	}

	return pluralClient.Plural(str)
}

func makeRestPath(fullName protoreflect.FullName) string {
	name := fullName.Name()
	parent := fullName.Parent()
	url := strings.Replace(string(parent), ".", "/", -1)
	url += "/" + pluralClient.Plural(strcase.ToSnake(string(name)))
	return url
}
